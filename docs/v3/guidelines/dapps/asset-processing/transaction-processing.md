Процессинг отправки сообщения от TL-B до полноценного взаимодействия в сети

В этом гайде мы разберём как из TL-B схемы можно написать скрипт на отправку любого сообщения в сеть. Для этого нам понадобится tl-b схема и установленное окружение Blueprint SDK, которое имеет все нужные нам пакеты (@ton/core, @ton/ton, @ton/blueprint). Но для начала углубимся в базовую терминологию.

# Терминология для понимания работы транзакций в блокчейне TON

## **Акторная модель**

**Акторная модель** в TON — это способ организации взаимодействия между различными частями блокчейна. Представьте, что каждый смарт-контракт — это отдельный "актор" (исполнитель), который:

- **Работает независимо** от других акторов
- **Обрабатывает сообщения** по очереди (одно за раз)
- **Может отправлять сообщения** другим акторам
- **Не делит состояние** с другими акторами

Это отличается от модели Ethereum, где все контракты работают в едином глобальном состоянии. В TON каждый контракт — самостоятельная единица.

## Асинхронность

**Асинхронность** означает, что операции в TON происходят **не мгновенно** и **не в строгой последовательности**:

- Когда вы отправляете транзакцию, она **не выполняется сразу**
- Сообщения между контрактами **доставляются с задержкой**
- Разные части сети могут **обрабатывать операции параллельно**
- **Гарантируется доставка**, но не время доставки

Это как отправка писем по почте — вы знаете, что письмо дойдет, но не знаете точно когда.

Пример:
Представим три контракта:
- **Контракт A**: Кошелек пользователя
- **Контракт B**: DEX (децентрализованная биржа)
- **Контракт C**: Пул ликвидности
### Как это работает в TON:

1. **Шаг 1**: Контракт A отправляет сообщение → **сразу завершает свою транзакцию**
2. **Шаг 2**: Контракт B получает сообщение → обрабатывает → отправляет дальше → **завершает транзакцию**
3. **Шаг 3**: Контракт C обрабатывает → отвечает → **завершает транзакцию**
4. **Шаг 4**: Контракт B получает ответ → отправляет результат пользователю

**Ключевая особенность**: Каждый контракт работает **независимо** и **не ждет** ответов от других.
### Как это работает в Ethereum:

1. **Одна большая транзакция** включает все вызовы
2. Все контракты **блокируются** до завершения
3. Если любой шаг **fails** → вся операция **откатывается**
4. **Весь процесс** должен завершиться в одном блоке

Почему асинхронная модель TON во многом превосходит синхронную модель Ethereum:
**Асинхронная модель TON** обеспечивает:

- **Лучшую масштабируемость** через параллелизм
-  **Меньшие затраты** на транзакции
-  **Высокую отказоустойчивость**
-  **Гибкость** в обработке сложных операций

**Синхронная модель Ethereum** имеет:

-  Ограничения по **газу** и **времени блока**
-  **Высокие затраты** на сложные операции
-  Риск **полного отката** при ошибках
-  **Последовательную** обработку (bottleneck)

Поэтому TON может обрабатывать **миллионы транзакций** в секунду, в то время как Ethereum ограничен **~15 транзакциями** в секунду.

## **Аккаунт**

**Аккаунт** в TON — это базовая единица, которая может:

- Хранить криптовалюту (TON coins)
- Выполнять код (если это смарт-контракт)
- Получать и отправлять сообщения
- Иметь уникальный адрес (256-битное число)
- Каждый аккаунт идентифицируется публичным ключом и может быть:

- - Простым кошельком (только хранит монеты)
- - Смарт-контрактом (выполняет программную логику)

## **Транзакция**

**Транзакция** в TON — это изменение состояния (стейта) одного конкретного аккаунта в результате обработки входящего сообщения.

Что такое "изменение стейта"?

Стейт (состояние) аккаунта включает:
Баланс, код смарт-контракта, данные (хранилище переменных в смарт-контракте) и статус (активен/заморожен/неинциализирован)

Пример изменения стейта: 
Аккаунт А (кошелек) отправил 1 тон другому Аккаунту Б (кошелек), в результате Аккаунт А имеет другой стейт, потому что баланс поменялся 

Эта архитектура делает TON **масштабируемым** — разные аккаунты могут обрабатывать транзакции параллельно, не мешая друг другу.

Теперь погрузимся более глубоко в работу транзакции:

## **Как понять что транзакция успешна?**

Когда в учетной записи в блокчейне TON происходит событие, оно запускает транзакцию. Наиболее распространенным событием является получение сообщения.

Каждая транзакция состоит из пяти этапов:

Этап хранения (Storage Phase): рассчитывает плату за хранение для контракта на основе места, которое он занимает в состоянии блокчейна.
Этап зачисления (Credit Phase): обновляет баланс контракта, учитывая стоимость входящих сообщений и плату за хранение.
Фаза вычислений (Compute Phase): выполняет код контракта в TVM. Результат включает в себя exit_code, actions, gas_details, new_storage и другие данные.
Фаза действий (Action Phase): обрабатывает действия из Compute Phase, если они завершаются успешно. Действия могут включать отправку сообщений, обновление кода контракта или изменение библиотек. Если действие завершается неудачей, например, из-за нехватки средств, транзакция может быть отменена или пропустить действие, в зависимости от ее режима (отправить или отменить или попробовать отправить, если нет, проигнорировать).
Фаза возврата (Bounce Phase): если на этапе вычисления происходит сбой (exit_code >= 2), на этом этапе генерируется сообщение об отказе для транзакций, инициированных входящим сообщением.

Если вам не хватает средств на этапе Storage Phase, то транзакция будет отклонена и не попадет в блокчейн.

Для Compute и Action phases существуеют exit codes - это 32-битные signed integer, которые в случае неудачной транзакции выдают число, означающие ошибку. Со всеми exit codes можно ознакомиться здесь: https://docs.ton.org/v3/documentation/tvm/tvm-exit-codes.

Если вы получили exit code = 0, то значит транзакция завершилась удачно. 
Пример: В Compute Phase вы получили exit code = 0, в Action Phase success = true, в Bounce Phase no_bounce - это означает полное выполнение, сообщение выполнилось без ошибок и баунса транзакции назад не было.
Но допустим может быть такой случай, вся транзакция прошла верно, но в Action Phase вы получили success = false, это означает что на этапе перемещения между аккаутами выпал exit code не равный 0. Чаще всего это может быть нехватка средств с учетом газа или дополнительных комиссий.
Также Action phase может быть not_executed, в таком случае при exit code = 1 (Alternative successful execution exit code. Reserved, but doesn't occur) и no_bounce сообщение полностью пройдет. ведь Action Phase не существует.

Частые примеры неудачных транзакций:
Недостаточно газа - Exit Code = 37. Пополните баланс кошелька перед повторной отправкой, если газ слишком дорогой, то поработайте над сокращением газа в смарт-контракте.
Underflow Cell - Exit Code = 9. Частая ошибка при сборке транзакции. В сообщение содержится недостаточно информации о переменных в контракте, чем надо. Пример: в контракте хранится storage из глобальных переменных, если пользователь при сборке скрипта пропустил одну из них, то появится эта ошибка.
Overflow Cell - Exit Code = 8. Аналог Undeflow Cell, только в этом случае пользователь перегрузил ячейку на отправку дополнительной информации, которой на самом деле нет и контракт не может это обработать. 
Underflow Stack - Exit Code  = 2. Частая ошибка, когда пользователь пытается взять элемент из пустого стека. Пример: 
```
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  ;; Стек пуст, но пытаемся взять элемент
  int value = null~load_uint(32);  ;; ОШИБКА: stack underflow
}
```
Всегда смотрите, точно ли вы берете элемент из существующего значения. Правильный пример: 
```
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  ;; Проверяем достаточность данных перед загрузкой
  if (slice_bits(in_msg_body) < 32) {
    return (); ;; Недостаточно данных для op
  }
  
  int op = in_msg_body~load_uint(32);
  
  if (slice_bits(in_msg_body) < 64) {
    return (); ;; Недостаточно данных для query_id
  }
  
  int query_id = in_msg_body~load_uint(64);
  
  ;; Проверяем наличие адреса (минимум 3 бита для типа)
  if (slice_bits(in_msg_body) < 3) {
    return ();
  }
  
  slice sender = in_msg_body~load_msg_addr();
}
```

Type Check Error - Exit code = 7. Возникает при неправильной распаковке данных. Пример:
```
() process_address(slice addr_slice) impure {
  ;; Попытка загрузить адрес как int
  int fake_addr = addr_slice~load_uint(267); ;; ERROR: type check
  
  ;; Неправильное приведение cell к slice
  cell some_cell = get_data();
  slice cs = some_cell; ;; ERROR: type check
}
```
Всегда следите как вы распаковываете типы в итоговых скриптах на отправку и в самом смарт-контракте, все должно соответствовать:
```
() process_address(slice addr_slice) impure {
  ;; Правильная загрузка адреса
  slice real_addr = addr_slice~load_msg_addr();
  
  ;; Правильное преобразование cell к slice
  cell some_cell = get_data();
  slice cs = some_cell.begin_parse();
  
  ;; Если нужно получить hash адреса
  int addr_hash = slice_hash(real_addr);
}
```
Здесь были разобраны самые популярные exit codes, возникающие у разработчиков. Всегда пользуйтесь сканерами, ретрейсерами и пишите тесты для своих смарт-контрактов, чтобы избежать ошибок.

## Анализ TL-B схемы

Теперь после базового погружения в термины, мы можем приступить к практическому применению наших знаний на постройке скрипта на отправку сообщения, пользуясь tl-b.

### TL-B Схема

Если вы не знакомы с тем, что такое tl-b, то ознакомиться можно здесь: https://docs.ton.org/v3/documentation/data-formats/tlb/tl-b-language. 

Представим, что мы имеем tl-b схему, сообщение из которой нам нужно упаковать в скрипт и отправить. В этом примере я взял tl-b с https://github.com/evaafi/contracts/blob/maiоn/schema/schema.tlb#L132.


```
tlb

revert_call#0000000f query_id:uint64 owner_address:MsgAddressInt revert_body:^Cell = InternalMsgBody
```

Прежде чем писать скрипт, давайте сначала разберём полученную нам tl-b схему.
#### Разбор структуры:

- `#0000000f` - оп-код, который ставится первым по порядку при формировании сообщения (всегда занимает 32 бита (uint32)). 
- `query_id:uint64` - Идентификатор запроса, который всегда ставится вторым по порядку при формировании сообщения (всегда занимает 64 бита (uint64))
- `owner_address:MsgAddressInt` - Адрес владельца (как правило, передаётся в смарт-контракте в виде slice)
- `revert_body:^Cell` - Ссылка на дополнительную ячейку (ссылка на ячейку, в которой лежит вся дополнительная информация для данной операции (cell)).

## Анализ FunC контракта

### FunC код:

Если вы не знакомы с языком FunC, то изучить его можно здесь: https://docs.ton.org/v3/documentation/smart-contracts/func/overview/. 

Теперь представим, что мы имеем FunC код, который демонстрирует как с помощью предыдущей tl-b схемы получилось удобно упаковать сообщение, которое нам нужно передать в скрипт и отправить. В этом примере я взял FunC код с https://github.com/evaafi/contracts/blob/main/contracts/logic/user-revert-call.fc. 

```
func 

() revert_call(
    slice sender_address, slice owner_address,
    slice in_msg_body
) impure method_id(0x770) {
    
    send_message(
        sender_address, 0,
        begin_cell()
        .store_uint(0x0000000f, 32)
        .store_uint(0, 64) ;; query_id
        .store_slice(owner_address) ;; 3+8+256
        ;; Part above is totalling: 32 + 64 + 3+8+256 = 363 bits,
        ;; which is significant -> Let's keep in_msg_body in a separate cell
        .store_ref(
            begin_cell().store_slice(in_msg_body).end_cell()
        ) ;; revert_body
        .end_cell(),
        64 ;; is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message.
    );
    commit(); 
    throw(error::user_code_version_mismatch);
}

```

Разберём важные моменты. В этом примере мы просто будем отправлять сообщение на нужный нам адрес, т. е. у нас нет recv_internal(), который бы скомпилировал контракт с этим оп-кодом и сообщением с ним, а только после этого мы бы на имеющийся контракт отправили нужное нам сообщение. 
Прежде чем идти писать скрипт, давайте проверим все ли аргументы нам подходят и все ли совпадает с tl-b схемой:
`.store_uint(0x0000000f, 32)` - этот оп-код нам подходит, так как его мы видели в tl-b схеме, также он стоит первым по списку.
`.store_uint(0, 64)` - query_id всегда передаётся в формате 64 битов, в данном случае у него номер 0.
`.store_slice(owner_address)` - третьим по списку передаётся адрес, как и в tl-b всё соответствует. 
`.store_ref(begin_cell().store_slice(in_msg_body).end_cell())` - четвёртым по списку передаётся cell, как и в tl-b всё соответствует.

Теперь когда мы уверены в том, что вся информация передана правильно, можно составлять сообщение благодаря Blueprint SDK. 
## 3. Typescript реализация

### Настройка окружения

Устанавливаем нужные нам модули: 

Команда npm create ton@latest установит окружение Blueprint SDK.

```
cd revert-call-msg
npm create ton@latest
или если вы хотите поставить только нужные вам модули, то сделайте так:
npm install @ton/core @ton/blueprint 
```

## Сборка скрипта на отправку сообщения

Когда вы установили все нужные модули создаём папку /scripts (в окружении Blueprint SDK) она есть сразу. Больше изучить работу в Blueprint SDK можно здесь: https://docs.ton.org/v3/documentation/smart-contracts/getting-started/javascript/. Весь следующий код будет разделён на шаги для простоты повестования, используйте его в одном файле.
Для простоты использования начнём с интерфейсами и передадим туда необходимые нам модули, такие как адрес смарт-контракта куда отправится наше сообщение, адрес владельца, query_id и revert_body. Для Cell и Address используем импортым из библиотеки @ton/core. После определения модулей в интерфейсе можно переходить к основной функции.  

```
typescript

import { 
  Address, 
  beginCell, 
  Cell, 
  toNano 
} from '@ton/core';
import { 
  NetworkProvider 
} from '@ton/blueprint';

interface RevertCallParams {
  contractAddress: Address;  // recipient msg address
  ownerAddress: Address;      
  queryId?: bigint;           
  revertBody?: Cell;         
}
```

В данной функции мы будем реализовывать основную логику отправки сообщения при помощи ранее созданного интерфейса. В contractAddress подставляется нужный адрес смарт-контракт для отправки сообщения. В ownerAddress подставляется адрес владельца контрактом, иначе при проверке смарт-контракта сообщение упадёт, ведь такого владельца не существует, а отправитель не имеет прав на отправку этого сообщения. revertBody упаковывается при помощи дополнительный функции, которая передаёт необходимый нам Cell in_msg_body. После этого сообщение отправляется с нужными нам аргументами. Теперь нам осталось лишь отправить это сообщение.

```
export async function run(provider: NetworkProvider) {
  const contractAddress = Address.parse(
    "EXISTING_CONTRACT_ADDRESS_HERE"
  );
  const ownerAddress = Address.parse(
    "OWNER_ADDRESS_HERE"
  );

  const revertBody = prepareRevertBody();

  await sendRevertCall(provider, {
    contractAddress,
    ownerAddress,
    queryId: 0n,
    revertBody
  });
}
```

В этой функции мы отправим нужное нам сообщение на нужный контракт. Создаём тело сообщения как это было в tl-b, а позднее и в смарт-контракте. Библиотека @ton/core сама даст нам нужные модули для составления сообщения, подобно как в смарт-контракте на FunC. Ставим обработку сообщения через try catch и отправляем сообщения на нужный адрес, учитывая fees на газ (обычно это около 0.05-0.1 тона) и вставляем наше тело. В конце добавляем ошибки, которые могут возникнуть при отправке сообщения (несовпадение адресов отправителей и админа смарт-контракта, нехватка тонов или неправильно построенное сообщение). 

```

async function sendRevertCall(
  provider: NetworkProvider, 
  params: RevertCallParams
) {
  // Создание тела сообщения
  const messageBody = beginCell()
    .storeUint(0x0000000f, 32)  // Op-код Revert Call
    .storeUint(params.queryId || 0n, 64)  // Query ID
    .storeAddress(params.ownerAddress)  // Адрес владельца
    .storeRef(params.revertBody)
    .endCell();

  try {
    await provider.sender().send({
      to: params.contractAddress,
      value: toNano('0.1'),  // Газ
      body: messageBody
    });

    console.log(`Сообщение revert-call отправлено на адрес: ${params.contractAddress}`);
  } catch (error) {
    console.error('Ошибка при отправке revert-call:', error);
  }
}

function prepareRevertBody(): Cell {
  return beginCell()
    .storeUint(0x01, 8)  
    .storeBuffer(
      Buffer.from('Данные для revert-call', 'utf-8')
    )
    .endCell();
}
```
