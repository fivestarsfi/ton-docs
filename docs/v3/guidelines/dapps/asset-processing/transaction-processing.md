Процессинг отправки сообщения от TL-B до полноценного взаимодействия в сети

В этом гайде мы разберём как из TL-B схемы можно написать скрипт на отправку любого сообщения в сеть. Для этого нам понадобится tl-b схема и установленное окружение Blueprint SDK, которое имеет все нужные нам пакеты (@ton/core, @ton/ton, @ton/blueprint). Но для начала углубимся в базовую терминологию.

# Терминология для понимания работы транзакций в блокчейне TON

## **Акторная модель**

**Акторная модель** в TON — это способ организации взаимодействия между различными частями блокчейна. Представьте, что каждый смарт-контракт — это отдельный "актор" (исполнитель), который:

- **Работает независимо** от других акторов
- **Обрабатывает сообщения** по очереди (одно за раз)
- **Может отправлять сообщения** другим акторам
- **Не делит состояние** с другими акторами

Это отличается от модели Ethereum, где все контракты работают в едином глобальном состоянии. В TON каждый контракт — самостоятельная единица.

## Асинхронность

**Асинхронность** означает, что операции в TON происходят **не мгновенно** и **не в строгой последовательности**:

- Когда вы отправляете транзакцию, она **не выполняется сразу**
- Сообщения между контрактами **доставляются с задержкой**
- Разные части сети могут **обрабатывать операции параллельно**
- **Гарантируется доставка**, но не время доставки

Это как отправка писем по почте — вы знаете, что письмо дойдет, но не знаете точно когда.

Пример:
Представим три контракта:
- **Контракт A**: Кошелек пользователя
- **Контракт B**: DEX (децентрализованная биржа)
- **Контракт C**: Пул ликвидности
### Как это работает в TON:

1. **Шаг 1**: Контракт A отправляет сообщение → **сразу завершает свою транзакцию**
2. **Шаг 2**: Контракт B получает сообщение → обрабатывает → отправляет дальше → **завершает транзакцию**
3. **Шаг 3**: Контракт C обрабатывает → отвечает → **завершает транзакцию**
4. **Шаг 4**: Контракт B получает ответ → отправляет результат пользователю

**Ключевая особенность**: Каждый контракт работает **независимо** и **не ждет** ответов от других.
### Как это работает в Ethereum:

1. **Одна большая транзакция** включает все вызовы
2. Все контракты **блокируются** до завершения
3. Если любой шаг **fails** → вся операция **откатывается**
4. **Весь процесс** должен завершиться в одном блоке

Почему асинхронная модель TON во многом превосходит синхронную модель Ethereum:
**Асинхронная модель TON** обеспечивает:

- **Лучшую масштабируемость** через параллелизм
-  **Меньшие затраты** на транзакции
-  **Высокую отказоустойчивость**
-  **Гибкость** в обработке сложных операций

**Синхронная модель Ethereum** имеет:

-  Ограничения по **газу** и **времени блока**
-  **Высокие затраты** на сложные операции
-  Риск **полного отката** при ошибках
-  **Последовательную** обработку (bottleneck)

Поэтому TON может обрабатывать **миллионы транзакций** в секунду, в то время как Ethereum ограничен **~15 транзакциями** в секунду.

## **Аккаунт**

**Транзакция** в TON — это **доставка одного входящего сообщения** к получающему аккаунту:

- **Одна транзакция = одно сообщение** к одному аккаунту
- Каждая транзакция **изменяет состояние** только одного аккаунта
- Транзакции **обрабатываются последовательно** для каждого аккаунта
- **Гарантируется выполнение** — если сообщение принято в блок, оно будет доставлено

Простыми словами: транзакция — это когда ваш аккаунт получил "письмо" и обработал его согласно своим правилам.

Эта архитектура делает TON **масштабируемым** — разные аккаунты могут обрабатывать транзакции параллельно, не мешая друг другу.
## Анализ TL-B схемы

Теперь после базового погружения в термины, мы можем приступить к практическому применению наших знаний на постройке скрипта на отправку сообщения, пользуясь tl-b.

### TL-B Схема

Если вы не знакомы с тем, что такое tl-b, то ознакомиться можно здесь: https://docs.ton.org/v3/documentation/data-formats/tlb/tl-b-language. 

Представим, что мы имеем tl-b схему, сообщение из которой нам нужно упаковать в скрипт и отправить. В этом примере я взял tl-b с https://github.com/evaafi/contracts/blob/maiоn/schema/schema.tlb#L132.


```
tlb

revert_call#0000000f query_id:uint64 owner_address:MsgAddressInt revert_body:^Cell = InternalMsgBody
```

Прежде чем писать скрипт, давайте сначала разберём полученную нам tl-b схему.
#### Разбор структуры:

- `#0000000f` - оп-код, который ставится первым по порядку при формировании сообщения (всегда занимает 32 бита (uint32)). 
- `query_id:uint64` - Идентификатор запроса, который всегда ставится вторым по порядку при формировании сообщения (всегда занимает 64 бита (uint64))
- `owner_address:MsgAddressInt` - Адрес владельца (как правило, передаётся в смарт-контракте в виде slice)
- `revert_body:^Cell` - Ссылка на дополнительную ячейку (ссылка на ячейку, в которой лежит вся дополнительная информация для данной операции (cell)).

## Анализ FunC контракта

### FunC код:

Если вы не знакомы с языком FunC, то изучить его можно здесь: https://docs.ton.org/v3/documentation/smart-contracts/func/overview/. 

Теперь представим, что мы имеем FunC код, который демонстрирует как с помощью предыдущей tl-b схемы получилось удобно упаковать сообщение, которое нам нужно передать в скрипт и отправить. В этом примере я взял FunC код с https://github.com/evaafi/contracts/blob/main/contracts/logic/user-revert-call.fc. 

```
func 

() revert_call(
    slice sender_address, slice owner_address,
    slice in_msg_body
) impure method_id(0x770) {
    
    send_message(
        sender_address, 0,
        begin_cell()
        .store_uint(0x0000000f, 32)
        .store_uint(0, 64) ;; query_id
        .store_slice(owner_address) ;; 3+8+256
        ;; Part above is totalling: 32 + 64 + 3+8+256 = 363 bits,
        ;; which is significant -> Let's keep in_msg_body in a separate cell
        .store_ref(
            begin_cell().store_slice(in_msg_body).end_cell()
        ) ;; revert_body
        .end_cell(),
        64 ;; is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message.
    );
    commit(); 
    throw(error::user_code_version_mismatch);
}

```

Разберём важные моменты. В этом примере мы просто будем отправлять сообщение на нужный нам адрес, т. е. у нас нет recv_internal(), который бы скомпилировал контракт с этим оп-кодом и сообщением с ним, а только после этого мы бы на имеющийся контракт отправили нужное нам сообщение. 
Прежде чем идти писать скрипт, давайте проверим все ли аргументы нам подходят и все ли совпадает с tl-b схемой:
`.store_uint(0x0000000f, 32)` - этот оп-код нам подходит, так как его мы видели в tl-b схеме, также он стоит первым по списку.
`.store_uint(0, 64)` - query_id всегда передаётся в формате 64 битов, в данном случае у него номер 0.
`.store_slice(owner_address)` - третьим по списку передаётся адрес, как и в tl-b всё соответствует. 
`.store_ref(begin_cell().store_slice(in_msg_body).end_cell())` - четвёртым по списку передаётся cell, как и в tl-b всё соответствует.

Теперь когда мы уверены в том, что вся информация передана правильно, можно составлять сообщение благодаря Blueprint SDK. 
## 3. Typescript реализация

### Настройка окружения

Устанавливаем нужные нам модули: 

Команда npm create ton@latest установит окружение Blueprint SDK.

```
cd revert-call-msg
npm create ton@latest
или если вы хотите поставить только нужные вам модули, то сделайте так:
npm install @ton/core @ton/blueprint 
```

## Сборка скрипта на отправку сообщения

Когда вы установили все нужные модули создаём папку /scripts (в окружении Blueprint SDK) она есть сразу. Больше изучить работу в Blueprint SDK можно здесь: https://docs.ton.org/v3/documentation/smart-contracts/getting-started/javascript/. Весь следующий код будет разделён на шаги для простоты повестования, используйте его в одном файле.
Для простоты использования начнём с интерфейсами и передадим туда необходимые нам модули, такие как адрес смарт-контракта куда отправится наше сообщение, адрес владельца, query_id и revert_body. Для Cell и Address используем импортым из библиотеки @ton/core. После определения модулей в интерфейсе можно переходить к основной функции.  

```
typescript

import { 
  Address, 
  beginCell, 
  Cell, 
  toNano 
} from '@ton/core';
import { 
  NetworkProvider 
} from '@ton/blueprint';

interface RevertCallParams {
  contractAddress: Address;  // recipient msg address
  ownerAddress: Address;      
  queryId?: bigint;           
  revertBody?: Cell;         
}
```

В данной функции мы будем реализовывать основную логику отправки сообщения при помощи ранее созданного интерфейса. В contractAddress подставляется нужный адрес смарт-контракт для отправки сообщения. В ownerAddress подставляется адрес владельца контрактом, иначе при проверке смарт-контракта сообщение упадёт, ведь такого владельца не существует, а отправитель не имеет прав на отправку этого сообщения. revertBody упаковывается при помощи дополнительный функции, которая передаёт необходимый нам Cell in_msg_body. После этого сообщение отправляется с нужными нам аргументами. Теперь нам осталось лишь отправить это сообщение.

```
export async function run(provider: NetworkProvider) {
  const contractAddress = Address.parse(
    "EXISTING_CONTRACT_ADDRESS_HERE"
  );
  const ownerAddress = Address.parse(
    "OWNER_ADDRESS_HERE"
  );

  const revertBody = prepareRevertBody();

  await sendRevertCall(provider, {
    contractAddress,
    ownerAddress,
    queryId: 0n,
    revertBody
  });
}
```

В этой функции мы отправим нужное нам сообщение на нужный контракт. Создаём тело сообщения как это было в tl-b, а позднее и в смарт-контракте. Библиотека @ton/core сама даст нам нужные модули для составления сообщения, подобно как в смарт-контракте на FunC. Ставим обработку сообщения через try catch и отправляем сообщения на нужный адрес, учитывая fees на газ (обычно это около 0.05-0.1 тона) и вставляем наше тело. В конце добавляем ошибки, которые могут возникнуть при отправке сообщения (несовпадение адресов отправителей и админа смарт-контракта, нехватка тонов или неправильно построенное сообщение). 

```

async function sendRevertCall(
  provider: NetworkProvider, 
  params: RevertCallParams
) {
  // Создание тела сообщения
  const messageBody = beginCell()
    .storeUint(0x0000000f, 32)  // Op-код Revert Call
    .storeUint(params.queryId || 0n, 64)  // Query ID
    .storeAddress(params.ownerAddress)  // Адрес владельца
    .storeRef(params.revertBody)
    .endCell();

  try {
    await provider.sender().send({
      to: params.contractAddress,
      value: toNano('0.1'),  // Газ
      body: messageBody
    });

    console.log(`Сообщение revert-call отправлено на адрес: ${params.contractAddress}`);
  } catch (error) {
    console.error('Ошибка при отправке revert-call:', error);
  }
}

function prepareRevertBody(): Cell {
  return beginCell()
    .storeUint(0x01, 8)  
    .storeBuffer(
      Buffer.from('Данные для revert-call', 'utf-8')
    )
    .endCell();
}
```
