# Smart contract addresses specification 

This section outlines how smart contract addresses work on the TON Blockchain and explains the concept of actors, equivalent to smart contracts in TON.

## Everything is a smart contract

On TON, all components are implemented using the [actor model](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains#single-actor). In this model, actors are essentially smart contracts. For example, even your wallet is an essential actor—technically, a smart contract.

Actors receive incoming messages, update their internal state, and send outbound messages in response. Because of this, every actor, i.e., a smart contract on the TON Blockchain, must have a unique address to receive messages from other actors.

:::info EVM EXPERIENCE
In the Ethereum Virtual Machine (EVM), addresses and smart contracts are distinct entities. For more on how TON differs from EVM-based systems, check out our article, ["Six unique aspects of TON Blockchain that will surprise solidity developers"](https://blog.ton.org/six-unique-aspects-of-ton-blockchain-that-will-surprise-solidity-developers) by _Tal Kol_.

:::

##  Smart contract addresses

On the TON Blockchain, smart contract addresses are composed of two main parts:
- `workchain_id`: a signed 32-bit integer that identifies the WorkChain.
- `account_id`: a bit string representing the account address. Its length can range from 64 to 512 bits, depending on the specific workchain.

We’ll dive deeper into how these `(workchain_id, account_id)` pairs are formatted in this documentation's [Raw address](/v3/documentation/smart-contracts/addresses#raw-address) section.


### WorkChain ID and Account ID

#### WorkChain ID
As [mentioned previously](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains#workchain-blockchain-with-your-own-rules), the TON Blockchain can support up to `2^32` workchains. Each smart contract address includes a 32-bit prefix that links it to a specific workchain. This structure enables smart contracts to communicate across different workchains.

Currently, only two WorkChains are active on TON:
- The MasterChain: `workchain_id = -1`
- The basic WorkChain: `workchain_id = 0`

Both use 256-bit addresses. As a result, in most cases, you can assume that `workchain_id` is either `0` or `-1` and that the `account_id` is precisely 256 bits in length.


#### Account ID

On the TON Blockchain, all account IDs use 256-bit addresses within both the MasterChain and the BaseChain, also known as the basic WorkChain.

An `account_id` is generated by applying a hash function—specifically, SHA-256—to a smart contract object. Every smart contract deployed on TON contains two core components:

1. _Compiled code_– the contract's logic is compiled into bytecode.
2. _Initial state_– the contract's state at the moment of deployment.


A hash is computed from the combination of its initial code and initial state to generate the smart contract's address. This results in the account ID:
`account_id = hash(initial code, initial state)`.

While we won't cover the [TVM](/v3/documentation/tvm/tvm-overview) in detail, it's essential to understand this core principle of how account IDs are formed.

In the upcoming sections, we'll explore the technical details behind raw addresses and user-friendly address formats.

Later in this documentation, we’ll look closer at the technical specifications of the TVM and the TL-B scheme. Now that you understand how an `account_id` is generated—and how it fits into the structure of smart contract addresses on TON—let’s move on to the concepts of raw and user-friendly addresses.

## Account state

On TON Blockchain, each address can exist in one of the following states:

- `nonexist` - the address has never received accepted transactions and contains no data. This also applies to addresses where a contract was deleted. By default, all 2<sup>256</sup> possible addresses begin in this state.

- `uninit` - the address holds some metadata and a balance but does not yet contain any smart contract code or persistent data. This state typically occurs when an address transitions from `nonexist` after receiving tokens for the first time.

- `active` - the address contains a smart contract code, persistent data, and a balance. The contract can execute logic during transactions and modify its persistent storage in this state. An address enters the `active` state when it receives an incoming message that includes the `state_init` parameter. Note: The hash of `state_init` and `code` must match the address to deploy the contract successfully.


- `frozen` - the address is inactive and cannot process any operations. Only two hashes are stored in this state—one for the code and one for the contract state. An address enters this state when its storage fees exceed its balance. To recover a frozen address, you must send an internal message containing `state_init`, the `code` matching the stored hashes, and some TON coins. Since recovery can be complex, it's best to avoid this scenario. You can learn more about unfreezing contracts [here](https://unfreezer.ton.org/).


## Raw and  user-friendly addresses
Now that we've covered how smart contract addresses on TON are constructed using `workchain_id` and `account_id`—specifically for the MasterChain and BaseChain—it's important to understand the two main formats in which these addresses are represented:

- **Raw addresses** – the full, original representation of smart contract addresses.
- **User-friendly addresses** – a human-readable version of the raw address that includes additional features for improved usability and security.

In the following sections, we’ll explore the key differences between these formats and explain why user-friendly addresses are the standard for interacting with TON Blockchain in most cases.

### Raw address

A raw smart contract address on TON consists of two components, the `workchain_id` and the `account_id`, represented in the following format:

* [decimal workchain_id\]:[64 hexadecimal digits with account_id\]

Here’s an example of a raw address with a `workchain_id` and an `account_id`:

`-1:fcb91a3a3816d0f7b8c2c76108b8a9bc5a6b7a55bd79f8ab101c52db29232260`

In this example, `-1` indicates the address belongs to the MasterChain as it’s `workchain_id`.

:::note
Hexadecimal characters in the address may appear in uppercase or lowercase; e.g., `A` and `a` are treated the same.
:::

#### Raw addresses issues

Using raw addresses comes with two primary limitations:

1. **No built-in error detection.** Raw addresses lack validation mechanisms. This means there's no way to verify the address before a transaction is sent. If you accidentally modify the address string—by adding, removing, or mistyping a character—the transaction could be sent to an incorrect destination, potentially resulting in permanent loss of funds.
2. **No support for additional flags.** Raw addresses do not support special flags, which are often required when sending transactions using user-friendly addresses. These flags enable extra features or behaviors during transaction processing. We'll cover the available flags and their purpose in the following section.

**Note:** despite these limitations in front-end development, using the raw address format is the most effective way to store addresses and handle logic on the back end. It is considered the preferred format for storage purposes.

### User-friendly address

User-friendly addresses were designed to enhance security and usability when sharing addresses—whether online, e.g., through messaging apps, email, or in offline, real-world contexts.

#### User-friendly address structure

User-friendly addresses on TON are exactly 36 bytes long and are constructed by combining the following components in sequence:



1. **[flags - 1 byte]** modify how smart contracts handle incoming messages. The following flags can be set in user-friendly address formats:

   - **isBounceable** indicates whether the address is bounceable or non-bounceable. _0x11_ for bounceable, _0x51_ for non-bounceable.
   - **isTestnetOnly** marks the address for testnet use only. Applications on the Mainnet should reject addresses starting with _0x80_.
   - **isUrlSafe** is a deprecated flag indicating URL safety. In practice, all addresses are treated as URL-safe.

2. **[workchain_id - 1 byte]** — a signed 8-bit integer identifying the WorkChain.
   - _0x00_ for the BaseChain
   - _0xff_ for the MasterChain

3. **[account_id - 32 byte]** - a 256-bit [big-endian](https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/) address that uniquely identifies the account within the WorkChain.

4. **[address verification - 2 bytes]** — a CRC16-CCITT checksum calculated over the previous 34 bytes. This is used to detect input errors, similar to how the [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used to validate credit card numbers. [Example implementation](https://github.com/andreypfau/ton-kotlin/blob/ce9595ec9e2ad0eb311351c8a270ef1bd2f4363e/ton-kotlin-crypto/common/src/crc32.kt).

In total: `1 (flags) + 1 (workchain ID) + 32 (account ID) + 2 (checksum) = 36 bytes`.
To convert these 36 bytes into a user-friendly address string, developers must encode the data using one of the following:

- **base64** uses standard characters: digits, uppercase/lowercase Latin letters, `/`, and `+`.
- **base64url** uses `_` and `-` instead of `/` and `+`.

This results in a 48-character, non-spaced string.

:::info DNS ADDRESS FLAGS
 
On TON, DNS-based addresses like `mywallet.ton` can be used instead of raw or user-friendly addresses. These DNS entries internally map to user-friendly addresses and include all necessary flags, enabling full access to metadata from the DNS record within the TON domain.
:::

#### User-friendly address encoding examples

Let's consider the "test giver" smart contract — a utility contract on the Testnet MasterChain that sends 2 test tokens to anyone who requests them. Its raw address is:

`-1:fcb91a3a3816d0f7b8c2c76108b8a9bc5a6b7a55bd79f8ab101c52db29232260`

To use this address in applications or share it with users, it should be converted to a user-friendly address format. This can be done using either **base64** or **base64URL** encoding, resulting in the following:

* **base64:** `kf/8uRo6OBbQ97jCx2EIuKm8Wmt6Vb15+KsQHFLbKSMiYIny` 
* **base64url:** `kf_8uRo6OBbQ97jCx2EIuKm8Wmt6Vb15-KsQHFLbKSMiYIny` 

:::info
Both **base64** and **base64url** formats are valid and must be accepted.
:::

#### Bounceable vs non-bounceable addresses

The bounceable flag was introduced to improve sender fund security.

When sending a message to a smart contract, if the contract doesn't exist or an error occurs during execution, a bounceable address ensures that the remaining value after gas and transfer fees is returned to the sender.
Here's how the flag works in practice:

1. The `bounceable=false` flag generally means the receiver is a wallet.
2. The `bounceable=true` flag typically denotes a custom smart contract with its application logic, such as a DEX. In this example, non-bounceable messages should not be sent for security reasons.

For more details, see our documentation on [non-bounceable messages](/v3/documentation/smart-contracts/message-management/non-bounceable-messages).

#### Armored base64 representations

The TON Blockchain also uses similar "armored" base64 formats to represent additional types of binary data in a user-friendly way. These formats can be distinguished based on the first four characters of their byte tag.

For example, a 256-bit Ed25519 public key is encoded by first creating a 36-byte sequence using the following structure:

- A single byte tag using the _0x3E_ format denotes a public key.
- A single byte tag using the _0xE6_ format denotes a Ed25519 public key.
- 32 bytes containing the standard binary representation of the Ed25519 public key.
- 2 bytes containing the big-endian representation of CRC16-CCITT of the previous 34 bytes.


This 36-byte sequence is then encoded into a 48-character string using standard base64 or base64URL encoding.

For example, the Ed25519 public key `E39ECDA0A7B0C60A7107EC43967829DBE8BC356A49B9DFC6186B3EAC74B5477D` represented as 32 bytes like `0xE3, 0x9E, ..., 0x7D` is transformed into the following armored representation:

`Pubjns2gp7DGCnEH7EOWeCnb6Lw1akm538YYaz6sdLVHfRB2`.


### Converting user-friendly addresses and raw addresses

The simplest way to convert user-friendly and raw addresses is to use one of several TON APIs and other tools, including:

* [ton.org/address](https://ton.org/address)
* [dton.io API method](https://dton.io/api/address/0:867ac2b47d1955de6c8e23f57994fad507ea3bcfe2a7d76ff38f29ec46729627)
* [TON center API methods in Mainnet](https://toncenter.com/api/v2/#/accounts/pack_address_packAddress_get)
* [TON center API methods in Testnet](https://testnet.toncenter.com/api/v2/#/accounts/pack_address_packAddress_get)

Additionally, there are two ways to convert user-friendly and raw addresses for wallets using JavaScript:

* [Convert address from/to user-friendly or raw form using ton.js](https://github.com/ton-org/ton-core/blob/main/src/address/Address.spec.ts)
* [Convert address from/to user-friendly or raw form using tonweb](https://github.com/toncenter/tonweb/tree/master/src/utils#address-class)

Similar mechanisms can also be implemented using [SDKs](/v3/guidelines/dapps/apis-sdks/sdk).

### Address examples

You can find more examples of TON addresses in the [TON cookbook](/v3/guidelines/dapps/cookbook#working-with-contracts-addresses).

## Possible issues

When interacting with the TON Blockchain, it’s important to understand what happens when you send TON coins to an `uninit` wallet address. This section breaks down the different scenarios and explains how the blockchain handles them.

### What happens when you send TON coins to an uninit address?

#### Transaction with state_init included

If your transaction includes the `state_init`, which contains the smart contract’s code and data, the contract will be deployed first using the provided `state_init`. Once deployed, the incoming message is processed just like it would be for an already-initialized contract.

#### Transaction without state_init and bounce flag enabled

The message cannot be delivered to the `uninit` smart contract and is bounced back to the sender. After deducting the consumed gas fees, the remaining amount is returned to the sender's address.

#### Transaction without state_init and bounce flag disabled

The message is not delivered and does not bounce back to the sender. Instead, the transferred amount is credited to the recipient's address, increasing its balance even though the wallet remains uninitialized. The funds are stored at the address until the owner deploys a smart wallet contract. At this point, the balance becomes accessible.

#### Best practice

The recommended way to deploy a wallet is to send TON to the wallet's uninitialized address with the `bounce` flag disabled. The wallet owner can then deploy the wallet using those funds—usually during their first wallet operation.

### Protection against erroneous transactions
Standard wallets and applications automatically handle the complexity of sending transactions to uninitialized addresses using bounceable and non-bounceable address formats on the TON Blockchain. These formats are explained in more detail [here](#bounceable-vs-non-bounceable-addresses). 

Wallets commonly handle transfers to uninitialized addresses by sending coins using bounceable and non-bounceable formats, ensuring the transaction proceeds without triggering a return of funds.

You can use the tool available [here](https://ton.org/address/) to convert an address to a bounceable or non-bounceable format quickly.

### Responsibility for custom products


Ensure your application verifies whether the recipient address is initialized before sending funds.
Based on the address state, use bounceable addresses for user smart contracts with custom application logic to ensure funds are returned. Use non-bounceable addresses for wallets.


If you're building a custom application on the TON Blockchain, it's crucial to implement similar logic to prevent errors:

- Ensure your application verifies whether the recipient address is initialized before sending any funds.
- Depending on the address state, use bounceable addresses for user smart contracts that require custom logic and refund protection.
- Use non-bounceable addresses for wallets.
